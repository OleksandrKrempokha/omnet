#include <iostream>
#include <fcntl.h> // For O_* constants
#include <sys/mman.h> // For shared memory
#include <sys/stat.h> // For mode constants
#include <unistd.h> // For ftruncate
#include <cstring> // For strlen
#include <string>
#include <time.h> // For nanosleep

void ReadFromSharedMemory(const std::string& sharedMemoryName) {
    const int SIZE = 1024 * 128; // 与写入时相同的大小
    std::string lastReadData; // 用于存储上一次读取的数据

    while (true) {
        // 打开共享内存对象
        int fd = shm_open(sharedMemoryName.c_str(), O_RDONLY, 0666);
        if (fd == -1) {
            std::cerr << "Failed to open shared memory: " << sharedMemoryName << std::endl;
            return;
        }

        // 将共享内存对象映射到进程的地址空间
        void* ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, fd, 0);
        if (ptr == MAP_FAILED) {
            std::cerr << "Failed to map shared memory: " << sharedMemoryName << std::endl;
            close(fd);
            return;
        }

        // 将共享内存中的数据转换为std::string，便于比较
        std::string currentData(static_cast<char*>(ptr));

        // 比较当前数据和上一次读取的数据
        if (currentData != lastReadData) {
            std::cout << "Data from shared memory: " << sharedMemoryName << std::endl;
            std::cout << currentData << std::endl;
            lastReadData = currentData; // 更新上一次读取的数据
        }

        // 解除映射并关闭共享内存对象的文件描述符
        munmap(ptr, SIZE);
        close(fd);

        // 简单的延时等待，减少CPU使用率
        struct timespec req, rem;
        req.tv_sec = 0; // 秒
        req.tv_nsec = 1000; // 100毫秒 = 100,000,000纳秒
        nanosleep(&req, &rem);
    }
}

int main() {
    ReadFromSharedMemory("hyperNet-online");
    return 0;
}
